

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DICOM dataSet &amp; tags classes &mdash; Imebra 4.0.8.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="copyright" title="Copyright" href="copyright.html"/>
    <link rel="top" title="Imebra 4.0.8.1 documentation" href="index.html"/>
        <link rel="next" title="Imaging classes" href="imaging_classes.html"/>
        <link rel="prev" title="Loading &amp; saving classes" href="loading_saving_classes.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Imebra
          

          
          </a>

          
            
            
              <div class="version">
                4.0.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Legal</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright</a></li>
<li class="toctree-l1"><a class="reference internal" href="gplv2.html">GNU General Public License</a></li>
</ul>
<p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes_log.html">Changes log</a></li>
</ul>
<p class="caption"><span class="caption-text">User documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="compiling_imebra.html">Compiling Imebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="add_to_project.html">Adding Imebra to your project</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick_tour.html">Getting started</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="definition_classes.html">Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="loading_saving_classes.html">Loading &amp; saving classes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DICOM dataSet &amp; tags classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dataset">DataSet</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tag">Tag</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tagid">TagId</a></li>
<li class="toctree-l2"><a class="reference internal" href="#readingdatahandler">ReadingDataHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="#readingdatahandlernumeric">ReadingDataHandlerNumeric</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writingdatahandler">WritingDataHandler</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writingdatahandlernumeric">WritingDataHandlerNumeric</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="imaging_classes.html">Imaging classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dicomdir_classes.html">DICOMDIR classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_management_classes.html">Memory management classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="transforms_classes.html">Transforms classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dicom_dictionary_classes.html">DICOM dictionary</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception_classes.html">Exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="objectivec_classes.html">ObjectiveC helpers</a></li>
</ul>
<p class="caption"><span class="caption-text">Build distributions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="build_distribution.html">Creating the source distribution from the code in the VCS</a></li>
<li class="toctree-l1"><a class="reference internal" href="build_distribution.html#versioning">Versioning</a></li>
</ul>
<p class="caption"><span class="caption-text">Requirements &amp; Risks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="risks_requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="risks_requirements.html#risks">Risks</a></li>
</ul>
<p class="caption"><span class="caption-text">Standard operating procedures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sop.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="sop.html#sops">SOPs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Imebra</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>DICOM dataSet &amp; tags classes</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/dicom_dataset_tag_classes.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dicom-dataset-tags-classes">
<h1>DICOM dataSet &amp; tags classes<a class="headerlink" href="#dicom-dataset-tags-classes" title="Permalink to this headline">¶</a></h1>
<p>This section describes the classes and methods responsible for retrieving and setting the information that composes the
DICOM structure, represented by the class <a class="reference internal" href="#_CPPv2N6imebra7DataSetE" title="imebra::DataSet"><code class="xref cpp cpp-class docutils literal"><span class="pre">imebra::DataSet</span></code></a>.</p>
<p>Each individual piece of information is stored into a tag (see <a class="reference internal" href="#_CPPv2N6imebra3TagE" title="imebra::Tag"><code class="xref cpp cpp-class docutils literal"><span class="pre">imebra::Tag</span></code></a>) inside the DICOM structure.</p>
<div class="section" id="dataset">
<h2>DataSet<a class="headerlink" href="#dataset" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N6imebra7DataSetE">
<span id="imebra::DataSet"></span><span class="target" id="imebraclassimebra_1_1_data_set"></span><em class="property">class </em><code class="descclassname">imebra::</code><code class="descname">DataSet</code><a class="headerlink" href="#_CPPv2N6imebra7DataSetE" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a DICOM dataset. </p>
<p>The information it contains is organized into groups and each group may contain several tags.</p>
<p>You can create a <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> from a DICOM file by using the <a class="reference internal" href="loading_saving_classes.html#imebraclassimebra_1_1_codec_factory_1ae1d2924aa682f5754215c27691791680"><span class="std std-ref">CodecFactory::load()</span></a> function:</p>
<p>In C++: <div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">imebra</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DataSet</span><span class="o">&gt;</span> <span class="n">pDataSet</span><span class="p">(</span><span class="n">CodecFactory</span><span class="p">::</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/file));</span>
</pre></div>
</div>
</p>
<p>In Java: <div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">com</span><span class="o">.</span><span class="n">imebra</span><span class="o">.</span><span class="n">DataSet</span> <span class="n">dataSet</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">imebra</span><span class="o">.</span><span class="n">CodecFactory</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/file&quot;</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p>You can also create an empty <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> that can be filled with data and images and then saved to a DICOM file via <a class="reference internal" href="loading_saving_classes.html#imebraclassimebra_1_1_codec_factory_1ac7b5fa45cb5450133fff02b48f70261f"><span class="std std-ref">CodecFactory::save()</span></a>.</p>
<p>When creating an empty <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> you should specify the proper transfer syntax in the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> constructor.</p>
<p>To retrieve the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>&#8216;s content, use one of the following methods which give direct access to the tags&#8217; values:<ul class="simple">
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a80bd1c810cb4c4b27683e85bdcfe0f3d"><span class="std std-ref">getImage()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a344d5f2383263f60dd9bfd7de99460ec"><span class="std std-ref">getImageApplyModalityTransform()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1ab1059031a7a494b4792502e63abb5e5f"><span class="std std-ref">getSequenceItem()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a5fcd3ba092cefb34fbc060fc925667e5"><span class="std std-ref">getSignedLong()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a05a742d8f9e948dfb4ee01ada7057107"><span class="std std-ref">getUnsignedLong()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a66f85bea74f08f4841f4d8dfb64b3b66"><span class="std std-ref">getDouble()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a5734c9dc711eaa173162524468cf5745"><span class="std std-ref">getString()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1af0544374dc503f127c68799a767b5858"><span class="std std-ref">getUnicodeString()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1ab957d30f594fbdda8e32cdfc7b38573c"><span class="std std-ref">getAge()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a071fe25703f9b39db8f2040265f7b409"><span class="std std-ref">getDate()</span></a></li>
</ul>
</p>
<p>In alternative, you can first retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> with <a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a07cb73035f85ecda6ef255408c44b876"><span class="std std-ref">getReadingDataHandler()</span></a> and then access the tag&#8217;s content via the handler.</p>
<p>To set the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>&#8216;s content, use one of the following methods:<ul class="simple">
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1ad9d0105847df32051b1169023a037043"><span class="std std-ref">setImage()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a45f5df7848725cf5f8f2637837dcedba"><span class="std std-ref">setSequenceItem()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1af16189397f05dad52cd9bb1190d3c46b"><span class="std std-ref">setSignedLong()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a1c8f47375e94122d57b909664fc8ea52"><span class="std std-ref">setUnsignedLong()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a4abb446871ce42a2d6a70c26d4568f5a"><span class="std std-ref">setDouble()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a9f951e32cb53be237c60f0208839b07b"><span class="std std-ref">setString()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1ad69e5d7c2e787d7f70ed9cafe6d9a155"><span class="std std-ref">setUnicodeString()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a6865189c59dd1c51eda6ef9f2f872ed0"><span class="std std-ref">setAge()</span></a></li>
<li><a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a46c15ececc48058b2cae043e24c19685"><span class="std std-ref">setDate()</span></a></li>
</ul>
</p>
<p>The previous methods allow to write just the first item in the tag&#8217;s content and before writing wipe out the old tag&#8217;s content (all the items). If you have to write more than one item in a tag, retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> with <a class="reference internal" href="#imebraclassimebra_1_1_data_set_1adb58aee90c373a1703f82d56ad5b1fa7"><span class="std std-ref">getWritingDataHandler()</span></a> and then modify all the tag&#8217;s items using the <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7DataSetEv">
<span id="imebra::DataSet::DataSet"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a2fa78b96cb4f5c85d7412c90f4e62fc3"></span><code class="descname">DataSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet7DataSetEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an empty DICOM dataset with unspecified transfer syntax (which represents the default value &#8220;1.2.840.10008.1.2&#8221; or &#8220;Implicit VR little endian&#8221;) and charset &#8220;ISO 2022 IR 6&#8221;. </p>
<p>Use this method when creating a <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> that will be embedded as a sequence item. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7DataSetERKNSt6stringE">
<span id="imebra::DataSet::DataSet__ssCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1aed0bba4a8239062e7f242b08625ef6c5"></span><code class="descname">DataSet</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>transferSyntax</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet7DataSetERKNSt6stringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an empty DICOM dataset with charset &#8220;ISO 2022 IR 6&#8221; and the desidered transfer syntax. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">transferSyntax</span></code> - <p>the dataSet&#8217;s transfer syntax. The following transfer syntaxes are supported:<ul class="simple">
<li>&#8220;1.2.840.10008.1.2&#8221; (Implicit VR little endian)</li>
<li>&#8220;1.2.840.10008.1.2.1&#8221; (Explicit VR little endian)</li>
<li>&#8220;1.2.840.10008.1.2.2&#8221; (Explicit VR big endian)</li>
<li>&#8220;1.2.840.10008.1.2.5&#8221; (RLE compression)</li>
<li>&#8220;1.2.840.10008.1.2.4.50&#8221; (Jpeg baseline 8 bit lossy)</li>
<li>&#8220;1.2.840.10008.1.2.4.51&#8221; (Jpeg extended 12 bit lossy)</li>
<li>&#8220;1.2.840.10008.1.2.4.57&#8221; (Jpeg lossless NH)</li>
<li>&#8220;1.2.840.10008.1.2.4.70&#8221; (Jpeg lossless NH first order prediction) </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7DataSetERKNSt6stringERK14charsetsList_t">
<span id="imebra::DataSet::DataSet__ssCR.charsetsList_tCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ad36a91862215bfac1632bb5c0ecdb751"></span><code class="descname">DataSet</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>transferSyntax</em>, <em class="property">const</em> charsetsList_t &amp;<em>charsets</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet7DataSetERKNSt6stringERK14charsetsList_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an empty DICOM dataset and specifies the default charsets. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">transferSyntax</span></code> - <p>the dataSet&#8217;s transfer syntax. The following transfer syntaxes are supported:<ul class="simple">
<li>&#8220;1.2.840.10008.1.2&#8221; (Implicit VR little endian)</li>
<li>&#8220;1.2.840.10008.1.2.1&#8221; (Explicit VR little endian)</li>
<li>&#8220;1.2.840.10008.1.2.2&#8221; (Explicit VR big endian)</li>
<li>&#8220;1.2.840.10008.1.2.5&#8221; (RLE compression)</li>
<li>&#8220;1.2.840.10008.1.2.4.50&#8221; (Jpeg baseline 8 bit lossy)</li>
<li>&#8220;1.2.840.10008.1.2.4.51&#8221; (Jpeg extended 12 bit lossy)</li>
<li>&#8220;1.2.840.10008.1.2.4.57&#8221; (Jpeg lossless NH)</li>
<li>&#8220;1.2.840.10008.1.2.4.70&#8221; (Jpeg lossless NH first order prediction)</li>
</ul>
</p>
</li>
<li><code class="first docutils literal"><span class="pre">charsets</span></code> - <p>a list of charsets supported by the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSetD0Ev">
<span id="imebra::DataSet::~DataSet"></span>virtual <span class="target" id="imebraclassimebra_1_1_data_set_1af877f61f1949e7214d2c61bad9bc621b"></span><code class="descname">~DataSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSetD0Ev" title="Permalink to this definition">¶</a></dt>
<dd><p>Destructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7getTagsEv">
<span id="imebra::DataSet::getTags"></span><span class="target" id="imebraclassimebra_1_1_data_set_1adbdf45b97c86d0788c10db8b30bc68fe"></span>tagsIds_t <code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet7getTagsEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all the tags stored in the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, ordered by group and tag ID. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an ordered list of the stored Tags </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet6getTagERK5TagId">
<span id="imebra::DataSet::getTag__TagIdCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a35242ae20988cc2c7e131146f882ebc2"></span><a class="reference internal" href="#_CPPv2N6imebra3TagE" title="imebra::Tag">Tag</a> *<code class="descname">getTag</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet6getTagERK5TagId" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the ID of the tag to retrieve </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet12getTagCreateERK5TagId7tagVR_t">
<span id="imebra::DataSet::getTagCreate__TagIdCR.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a60338e2116e443739c16b2d2f3d87eeb"></span><a class="reference internal" href="#_CPPv2N6imebra3TagE" title="imebra::Tag">Tag</a> *<code class="descname">getTagCreate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet12getTagCreateERK5TagId7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID or create it if it doesn&#8217;t exist. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the ID of the tag to retrieve </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the VR to use for the new tag if one doesn&#8217;t exist already </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet12getTagCreateERK5TagId">
<span id="imebra::DataSet::getTagCreate__TagIdCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ab97ea8cc426a1f09305352c9a8f38ead"></span><a class="reference internal" href="#_CPPv2N6imebra3TagE" title="imebra::Tag">Tag</a> *<code class="descname">getTagCreate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet12getTagCreateERK5TagId" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID or create it if it doesn&#8217;t exist. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the ID of the tag to retrieve </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet8getImageE6size_t">
<span id="imebra::DataSet::getImage__s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a80bd1c810cb4c4b27683e85bdcfe0f3d"></span><a class="reference internal" href="imaging_classes.html#_CPPv2N6imebra5ImageE" title="imebra::Image">Image</a> *<code class="descname">getImage</code><span class="sig-paren">(</span>size_t <em>frameNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet8getImageE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image from the dataset. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_set_image_doesnt_exist_error"><span class="std std-ref">DataSetImageDoesntExistError</span></a> if the requested frame does not exist.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Images retrieved from the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> should be processed by the <a class="reference internal" href="transforms_classes.html#imebraclassimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> transform, which converts the modality-specific pixel values to values that the application can understand. Consider using <a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a344d5f2383263f60dd9bfd7de99460ec"><span class="std std-ref">getImageApplyModalityTransform()</span></a> to retrieve the image already processed by <a class="reference internal" href="transforms_classes.html#imebraclassimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a>.</dd>
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="imaging_classes.html#imebraclassimebra_1_1_image"><span class="std std-ref">Image</span></a> object containing the decompressed image </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">frameNumber</span></code> - <p>the frame to retrieve (the first frame is 0) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet30getImageApplyModalityTransformE6size_t">
<span id="imebra::DataSet::getImageApplyModalityTransform__s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a344d5f2383263f60dd9bfd7de99460ec"></span><a class="reference internal" href="imaging_classes.html#_CPPv2N6imebra5ImageE" title="imebra::Image">Image</a> *<code class="descname">getImageApplyModalityTransform</code><span class="sig-paren">(</span>size_t <em>frameNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet30getImageApplyModalityTransformE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an image from the dataset and if necessary process it with <a class="reference internal" href="transforms_classes.html#imebraclassimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> before returning it. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_set_image_doesnt_exist_error"><span class="std std-ref">DataSetImageDoesntExistError</span></a> if the requested frame does not exist.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an image object containing the decompressed image processed with <a class="reference internal" href="transforms_classes.html#imebraclassimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">frameNumber</span></code> - <p>the frame to retrieve (the first frame is 0) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet8setImageE6size_tRK5Image14imageQuality_t">
<span id="imebra::DataSet::setImage__s.ImageCR.imageQuality_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ad9d0105847df32051b1169023a037043"></span>void <code class="descname">setImage</code><span class="sig-paren">(</span>size_t <em>frameNumber</em>, <em class="property">const</em> <a class="reference internal" href="imaging_classes.html#_CPPv2N6imebra5ImageE" title="imebra::Image">Image</a> &amp;<em>image</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra14imageQuality_tE" title="imebra::imageQuality_t">imageQuality_t</a> <em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet8setImageE6size_tRK5Image14imageQuality_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an image into the dataset. </p>
<p>In multi-frame datasets the images must be inserted in order: first, insert the frame 0, then the frame 1, then the frame 2 and so on.</p>
<p>All the inserted images must have the same transfer syntax and the same properties (size, color space, high bit, bits allocated).</p>
<p>If the images are inserted in the wrong order then the <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_set_wrong_frame_error"><span class="std std-ref">DataSetWrongFrameError</span></a> exception is thrown.</p>
<p>If the image being inserted has different properties than the ones of the images already in the dataset then the exception <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_set_different_format_error"><span class="std std-ref">DataSetDifferentFormatError</span></a> is thrown.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">frameNumber</span></code> - <p>the frame number (the first frame is 0) </p>
</li>
<li><code class="first docutils literal"><span class="pre">image</span></code> - <p>the image </p>
</li>
<li><code class="first docutils literal"><span class="pre">quality</span></code> - <p>the quality to use for lossy compression. Ignored if lossless compression is used </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7getVOIsEv">
<span id="imebra::DataSet::getVOIs"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a08881970f437016c630f8440abdda90a"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra6vois_tE" title="imebra::vois_t">vois_t</a> <code class="descname">getVOIs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet7getVOIsEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of VOI settings stored in the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>. </p>
<p>Each VOI setting includes the center &amp; width values that can be used with the <a class="reference internal" href="transforms_classes.html#imebraclassimebra_1_1_v_o_i_l_u_t"><span class="std std-ref">VOILUT</span></a> transform to highlight different parts of an <a class="reference internal" href="imaging_classes.html#imebraclassimebra_1_1_image"><span class="std std-ref">Image</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a list of <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_v_o_i_description"><span class="std std-ref">VOIDescription</span></a> objects defined in the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet15getSequenceItemERK5TagId6size_t">
<span id="imebra::DataSet::getSequenceItem__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ab1059031a7a494b4792502e63abb5e5f"></span><a class="reference internal" href="#_CPPv2N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> *<code class="descname">getSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet15getSequenceItemERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a sequence item stored in a tag. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified sequence item then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the requested sequence item </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the sequence item </p>
</li>
<li><code class="first docutils literal"><span class="pre">itemId</span></code> - <p>the sequence item to retrieve. The first item has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet15setSequenceItemERK5TagId6size_tRK7DataSet">
<span id="imebra::DataSet::setSequenceItem__TagIdCR.s.DataSetCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a45f5df7848725cf5f8f2637837dcedba"></span>void <code class="descname">setSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> &amp;<em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet15setSequenceItemERK5TagId6size_tRK7DataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a sequence item. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then creates a new one with VR tagVR_t::SQ.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id in which the sequence must be stored </p>
</li>
<li><code class="first docutils literal"><span class="pre">itemId</span></code> - <p>the sequence item to set. The first item has an Id = 0 </p>
</li>
<li><code class="first docutils literal"><span class="pre">item</span></code> - <p>the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> to store as a sequence item </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet6getLUTERK5TagId6size_t">
<span id="imebra::DataSet::getLUT__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1af828670ac04a6cbcec76f084682455af"></span>LUT *<code class="descname">getLUT</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet6getLUTERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a LUT stored in a sequence item. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified sequence item then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the LUT stored in the requested sequence item </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the sequence that stores the LUTs </p>
</li>
<li><code class="first docutils literal"><span class="pre">itemId</span></code> - <p>the sequence item to retrieve. The first item has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t">
<span id="imebra::DataSet::getReadingDataHandler__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a07cb73035f85ecda6ef255408c44b876"></span><a class="reference internal" href="#_CPPv2N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a> *<code class="descname">getReadingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to a specific tag&#8217;s buffer. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to the requested <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the buffer to connect to the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t">
<span id="imebra::DataSet::getWritingDataHandler__TagIdCR.s.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1adb58aee90c373a1703f82d56ad5b1fa7"></span><a class="reference internal" href="#_CPPv2N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> *<code class="descname">getWritingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag&#8217;s buffer. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s VR </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t">
<span id="imebra::DataSet::getWritingDataHandler__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a80b09a86210c671f15a020342c572058"></span><a class="reference internal" href="#_CPPv2N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> *<code class="descname">getWritingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag&#8217;s buffer. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t">
<span id="imebra::DataSet::getReadingDataHandlerNumeric__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a1a7342f15183fba34896f942894d1755"></span><a class="reference internal" href="#_CPPv2N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a getReadingDataHandlerNumeric object connected to a specific tag&#8217;s numeric buffer. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the requested <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the buffer to connect to the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t">
<span id="imebra::DataSet::getReadingDataHandlerRaw__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a1f8f2b23ffd9aa685ecf9bf86b74d156"></span><a class="reference internal" href="#_CPPv2N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a getReadingDataHandlerNumeric object connected to a specific tag&#8217;s buffer, no matter what the tag&#8217;s data type. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the requested <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the buffer to connect to the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t">
<span id="imebra::DataSet::getWritingDataHandlerNumeric__TagIdCR.s.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a233dcbcc42fe5e9be402ee0589df7c8b"></span><a class="reference internal" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag&#8217;s buffer. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s VR </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t">
<span id="imebra::DataSet::getWritingDataHandlerNumeric__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a990fef188bcaed35edc25ddd967f319e"></span><a class="reference internal" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag&#8217;s buffer. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t">
<span id="imebra::DataSet::getWritingDataHandlerRaw__TagIdCR.s.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a31bac69fb8cfe13ec79d2c3d2048818e"></span><a class="reference internal" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag&#8217;s buffer. The handler content is cast to bytes. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s VR </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t">
<span id="imebra::DataSet::getWritingDataHandlerRaw__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ad1beefeeeb2ee908c6e7748c2738ab20"></span><a class="reference internal" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag&#8217;s buffer. The handler content is cast to bytes. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id containing the requested buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet12bufferExistsERK5TagId6size_t">
<span id="imebra::DataSet::bufferExists__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a4ea6782c072efd73048b3c9fd8f0a3fc"></span>bool <code class="descname">bufferExists</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet12bufferExistsERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the specified tag and tag&#8217;s buffer exist. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the specified tag and tag&#8217;s buffer exist, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet13getSignedLongERK5TagId6size_t">
<span id="imebra::DataSet::getSignedLong__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a5fcd3ba092cefb34fbc060fc925667e5"></span>std::int32_t <code class="descname">getSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet13getSignedLongERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as signed long integer (32 bit). </p>
<p>If the tag&#8217;s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a signed 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE">
<span id="imebra::DataSet::getSignedLong__TagIdCR.s.std::int32_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a1faa3cab9a2268c1c14dd279ea78d2ec"></span>std::int32_t <code class="descname">getSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::int32_t <em>defaultValue</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as signed long integer (32 bit). </p>
<p>If the tag&#8217;s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist or it does not contain the specified buffer then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a signed 32 bit integer, or defaultValue if the tag doesn&#8217;t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">defaultValue</span></code> - <p>the value to return if the tag doesn&#8217;t exist </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t">
<span id="imebra::DataSet::setSignedLong__TagIdCR.std::int32_t.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1af16189397f05dad52cd9bb1190d3c46b"></span>void <code class="descname">setSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don&#8217;t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newValue</span></code> - <p>the value to write into the tag </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s type to use when a new tag is created. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE">
<span id="imebra::DataSet::setSignedLong__TagIdCR.std::int32_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ab417f8af9cb7f7802456b666f621fdbe"></span>void <code class="descname">setSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newValue</span></code> - <p>the value to write into the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet15getUnsignedLongERK5TagId6size_t">
<span id="imebra::DataSet::getUnsignedLong__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a05a742d8f9e948dfb4ee01ada7057107"></span>std::uint32_t <code class="descname">getUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet15getUnsignedLongERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as unsigned long integer (32 bit). </p>
<p>If the tag&#8217;s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as an unsigned 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE">
<span id="imebra::DataSet::getUnsignedLong__TagIdCR.s.std::uint32_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a11b3f173bec4fd2ac9de8141061a3019"></span>std::uint32_t <code class="descname">getUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::uint32_t <em>defaultValue</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as unsigned long integer (32 bit). </p>
<p>If the tag&#8217;s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as an unsigned 32 bit integer, or defaultValue if the tag doesn&#8217;t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">defaultValue</span></code> - <p>the value to return if the tag doesn&#8217;t exist </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t">
<span id="imebra::DataSet::setUnsignedLong__TagIdCR.std::uint32_t.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a1c8f47375e94122d57b909664fc8ea52"></span>void <code class="descname">setUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn&#8217;t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newValue</span></code> - <p>the value to write into the tag </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s type to use when a new tag is created. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE">
<span id="imebra::DataSet::setUnsignedLong__TagIdCR.std::uint32_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a8c3e2fc0057bcd1bcdf66142a0f9516d"></span>void <code class="descname">setUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newValue</span></code> - <p>the value to write into the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9getDoubleERK5TagId6size_t">
<span id="imebra::DataSet::getDouble__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a66f85bea74f08f4841f4d8dfb64b3b66"></span>double <code class="descname">getDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet9getDoubleERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as a 64 bit floating point. </p>
<p>If the tag&#8217;s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a 64 bit floating point </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9getDoubleERK5TagId6size_td">
<span id="imebra::DataSet::getDouble__TagIdCR.s.double"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a3fd813cab7f5f10206d278c4a754a1ea"></span>double <code class="descname">getDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, double <em>defaultValue</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet9getDoubleERK5TagId6size_td" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as a 64 bit floating point. </p>
<p>If the tag&#8217;s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a 64 bit floating point, or defaultValue if the tag doesn&#8217;t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">defaultValue</span></code> - <p>the value to return if the tag doesn&#8217;t exist </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9setDoubleERK5TagIdd7tagVR_t">
<span id="imebra::DataSet::setDouble__TagIdCR.double.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a4abb446871ce42a2d6a70c26d4568f5a"></span>void <code class="descname">setDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, double <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet9setDoubleERK5TagIdd7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a 64 bit floating point value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don&#8217;t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newValue</span></code> - <p>the value to write into the tag </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s type to use when a new tag is created. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9setDoubleERK5TagIdd">
<span id="imebra::DataSet::setDouble__TagIdCR.double"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a5e904c4c2ce83c4366ee1c53b634d0c1"></span>void <code class="descname">setDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, double <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet9setDoubleERK5TagIdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a 64 bit floating point value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newValue</span></code> - <p>the value to write into the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9getStringERK5TagId6size_t">
<span id="imebra::DataSet::getString__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a5734c9dc711eaa173162524468cf5745"></span>std::string <code class="descname">getString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet9getStringERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as a string. </p>
<p>If the tag&#8217;s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE">
<span id="imebra::DataSet::getString__TagIdCR.s.ssCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1aac3c10c69801d6471414fbc9293d0317"></span>std::string <code class="descname">getString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> std::string &amp;<em>defaultValue</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as a string. </p>
<p>If the tag&#8217;s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a string, or defaultValue if the tag doesn&#8217;t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">defaultValue</span></code> - <p>the value to return if the tag doesn&#8217;t exist </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t">
<span id="imebra::DataSet::setString__TagIdCR.ssCR.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a9f951e32cb53be237c60f0208839b07b"></span>void <code class="descname">setString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::string &amp;<em>newString</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a string value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a specific VR.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newString</span></code> - <p>the string to write into the tag </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s type to use when a new tag is created. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE">
<span id="imebra::DataSet::setString__TagIdCR.ssCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ac1d2047d907db4dd6efc3953cc4fe7bc"></span>void <code class="descname">setString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::string &amp;<em>newString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a string value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newString</span></code> - <p>the string to write into the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet16getUnicodeStringERK5TagId6size_t">
<span id="imebra::DataSet::getUnicodeString__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1af0544374dc503f127c68799a767b5858"></span>std::wstring <code class="descname">getUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet16getUnicodeStringERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as an Unicode string. </p>
<p>If the tag&#8217;s value cannot be converted to a Unicode string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as an unicode string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE">
<span id="imebra::DataSet::getUnicodeString__TagIdCR.s.std::wstringCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ad60cae2bf20f9bda3605c80286aaab52"></span>std::wstring <code class="descname">getUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> std::wstring &amp;<em>defaultValue</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as an unicode string. </p>
<p>If the tag&#8217;s value cannot be converted to a Unicode string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as an unicode string, or defaultValue if the tag doesn&#8217;t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">defaultValue</span></code> - <p>the value to return if the tag doesn&#8217;t exist </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t">
<span id="imebra::DataSet::setUnicodeString__TagIdCR.std::wstringCR.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ad69e5d7c2e787d7f70ed9cafe6d9a155"></span>void <code class="descname">setUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::wstring &amp;<em>newString</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an unicode string value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn&#8217;t exist then a new tag is created using the specified VR.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newString</span></code> - <p>the string to write into the tag </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s type to use when a new tag is created. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE">
<span id="imebra::DataSet::setUnicodeString__TagIdCR.std::wstringCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1acc9f54e3589f383fff7b6cd4c7db7e86"></span>void <code class="descname">setUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::wstring &amp;<em>newString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an unicode string value into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">newString</span></code> - <p>the string to write into the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet6getAgeERK5TagId6size_t">
<span id="imebra::DataSet::getAge__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1ab957d30f594fbdda8e32cdfc7b38573c"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra3AgeE" title="imebra::Age">Age</a> *<code class="descname">getAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet6getAgeERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the tag&#8217;s value cannot be converted to <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet6getAgeERK5TagId6size_tRK3Age">
<span id="imebra::DataSet::getAge__TagIdCR.s.AgeCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a54fea5a007b5110977190a5ac1c28ab7"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra3AgeE" title="imebra::Age">Age</a> *<code class="descname">getAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet6getAgeERK5TagId6size_tRK3Age" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the tag&#8217;s value cannot be converted to <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a>, or defaultValue if the tag doesn&#8217;t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer 0 </p>
</li>
<li><code class="first docutils literal"><span class="pre">defaultValue</span></code> - <p>the value to return if the tag doesn&#8217;t exist </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet6setAgeERK5TagIdRK3Age">
<span id="imebra::DataSet::setAge__TagIdCR.AgeCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a6865189c59dd1c51eda6ef9f2f872ed0"></span>void <code class="descname">setAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>age</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet6setAgeERK5TagIdRK3Age" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> string into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn&#8217;t exist then a new tag and is created using the VR tagVR_t::AS.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">age</span></code> - <p>the <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> to write into the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7getDateERK5TagId6size_t">
<span id="imebra::DataSet::getDate__TagIdCR.s"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a071fe25703f9b39db8f2040265f7b409"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra4DateE" title="imebra::Date">Date</a> *<code class="descname">getDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet7getDateERK5TagId6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a>. </p>
<p>If the tag&#8217;s value cannot be converted to a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a> then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7getDateERK5TagId6size_tRK4Date">
<span id="imebra::DataSet::getDate__TagIdCR.s.DateCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a1890764f75d715864fd4b0998c2a3665"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra4DateE" title="imebra::Date">Date</a> *<code class="descname">getDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet7getDateERK5TagId6size_tRK4Date" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a tag&#8217;s value as a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a>. </p>
<p>If the tag&#8217;s value cannot be converted to a date then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a>, or defaultValue if the tag doesn&#8217;t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">elementNumber</span></code> - <p>the element number within the buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">defaultValue</span></code> - <p>the value to return if the tag doesn&#8217;t exist </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7setDateERK5TagIdRK4Date7tagVR_t">
<span id="imebra::DataSet::setDate__TagIdCR.DateCR.tagVR_t"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a46c15ececc48058b2cae043e24c19685"></span>void <code class="descname">setDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em>, <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet7setDateERK5TagIdRK4Date7tagVR_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a> string into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don&#8217;t exist then a new tag and/or buffer are created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">date</span></code> - <p>the <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a> to write into the tag </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagVR</span></code> - <p>the tag&#8217;s type to use when a new tag is created. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet7setDateERK5TagIdRK4Date">
<span id="imebra::DataSet::setDate__TagIdCR.DateCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1a42da4db86f32abaa81b241702009bd9f"></span>void <code class="descname">setDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra7DataSet7setDateERK5TagIdRK4Date" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a> string into the element 0 of the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#imebraclassimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag&#8217;s id </p>
</li>
<li><code class="first docutils literal"><span class="pre">date</span></code> - <p>the <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a> to write into the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra7DataSet11getDataTypeERK5TagId">
<span id="imebra::DataSet::getDataType__TagIdCR"></span><span class="target" id="imebraclassimebra_1_1_data_set_1aa5f4f4c3632b6533bbb383f22542023a"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra7DataSet11getDataTypeERK5TagId" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2 chars data type (VR) of the specified tag. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s data type (VR) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the id of the tag </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="tag">
<h2>Tag<a class="headerlink" href="#tag" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N6imebra3TagE">
<span id="imebra::Tag"></span><span class="target" id="imebraclassimebra_1_1_tag"></span><em class="property">class </em><code class="descclassname">imebra::</code><code class="descname">Tag</code><a class="headerlink" href="#_CPPv2N6imebra3TagE" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a DICOM tag. </p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6imebra3Tag15getBuffersCountEv">
<span id="imebra::Tag::getBuffersCount"></span><span class="target" id="imebraclassimebra_1_1_tag_1ad7dfe729d258039a51a8bbec1e1f8c06"></span>size_t <code class="descname">getBuffersCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag15getBuffersCountEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of buffers in the tag. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of buffers in the tag </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag12bufferExistsE6size_t">
<span id="imebra::Tag::bufferExists__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1a0d6e5bc4bd8415d58e628b82b5b5533c"></span>bool <code class="descname">bufferExists</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag12bufferExistsE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the specified buffer exists, otherwise it returns false. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the buffer exists, false otherwise </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the zero-based buffer&#8217;s id the function has to check for </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag13getBufferSizeE6size_t">
<span id="imebra::Tag::getBufferSize__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1a5b0f2fe0ce9dfb125598e5ffbeef43cf"></span>size_t <code class="descname">getBufferSize</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag13getBufferSizeE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of a buffer, in bytes. </p>
<p>If the buffer doesn&#8217;t exist then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the buffer&#8217;s size in bytes </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the zero-based buffer&#8217;s id the function has to check for </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag21getReadingDataHandlerE6size_t">
<span id="imebra::Tag::getReadingDataHandler__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1aa41344971a5dab80f2aa7cf043ff4510"></span><a class="reference internal" href="#_CPPv2N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a> *<code class="descname">getReadingDataHandler</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag21getReadingDataHandlerE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to a specific buffer. </p>
<p>If the specified buffer does not exist then throws or <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to the requested buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the buffer to connect to the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag21getWritingDataHandlerE6size_t">
<span id="imebra::Tag::getWritingDataHandler__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1adff439da273315a0ae9f64af917b12ce"></span><a class="reference internal" href="#_CPPv2N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> *<code class="descname">getWritingDataHandler</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra3Tag21getWritingDataHandlerE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag&#8217;s buffer. </p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored in the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored into the tag. The first buffer position is 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag28getReadingDataHandlerNumericE6size_t">
<span id="imebra::Tag::getReadingDataHandlerNumeric__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1a002828146be934d5b21bb57f78abd8a8"></span><a class="reference internal" href="#_CPPv2N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerNumeric</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag28getReadingDataHandlerNumericE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s numeric buffer. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the buffer to connect to the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag24getReadingDataHandlerRawE6size_t">
<span id="imebra::Tag::getReadingDataHandlerRaw__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1a7151e54a3361cb03c6f71b27287a94fa"></span><a class="reference internal" href="#_CPPv2N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerRaw</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag24getReadingDataHandlerRawE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer (raw content represented by 8 bit unsigned integers) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the buffer to connect to the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag28getWritingDataHandlerNumericE6size_t">
<span id="imebra::Tag::getWritingDataHandlerNumeric__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1a2ca57a048244f55946cab38a61ec785d"></span><a class="reference internal" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra3Tag28getWritingDataHandlerNumericE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer. </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag24getWritingDataHandlerRawE6size_t">
<span id="imebra::Tag::getWritingDataHandlerRaw__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1ada0b04f3aab67abc8d43521ed7a36314"></span><a class="reference internal" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra3Tag24getWritingDataHandlerRawE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag&#8217;s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer (the buffer contains raw data of 8 bit integers) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag15getStreamReaderE6size_t">
<span id="imebra::Tag::getStreamReader__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1afa7652b6c740bf2c313941a8dd4a6502"></span><a class="reference internal" href="loading_saving_classes.html#_CPPv2N6imebra12StreamReaderE" title="imebra::StreamReader">StreamReader</a> *<code class="descname">getStreamReader</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra3Tag15getStreamReaderE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a <a class="reference internal" href="loading_saving_classes.html#imebraclassimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> connected to a buffer&#8217;s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the streamReader connected to the buffer&#8217;s data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the id of the buffer for which the <a class="reference internal" href="loading_saving_classes.html#imebraclassimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> is required. This parameter is usually 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag15getStreamWriterE6size_t">
<span id="imebra::Tag::getStreamWriter__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1a4c1015533543ccf73beab22a5f8c2a7f"></span><a class="reference internal" href="loading_saving_classes.html#_CPPv2N6imebra12StreamWriterE" title="imebra::StreamWriter">StreamWriter</a> *<code class="descname">getStreamWriter</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra3Tag15getStreamWriterE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a <a class="reference internal" href="loading_saving_classes.html#imebraclassimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to a buffer&#8217;s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="loading_saving_classes.html#imebraclassimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to the buffer&#8217;s data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">bufferId</span></code> - <p>the id of the buffer for which the <a class="reference internal" href="loading_saving_classes.html#imebraclassimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> is required. This parameter is usually 0 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag15getSequenceItemE6size_t">
<span id="imebra::Tag::getSequenceItem__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1a54ac15fe6083469d9649b8878ffd7216"></span><a class="reference internal" href="#_CPPv2N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> *<code class="descname">getSequenceItem</code><span class="sig-paren">(</span>size_t <em>dataSetId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag15getSequenceItemE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an embedded <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>. </p>
<p>Sequence tags (VR=SQ) store embedded dicom structures.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the sequence <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">dataSetId</span></code> - <p>the ID of the sequence item to retrieve. Several sequence items can be embedded in one tag. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag18sequenceItemExistsE6size_t">
<span id="imebra::Tag::sequenceItemExists__s"></span><span class="target" id="imebraclassimebra_1_1_tag_1affff34b6ee59985bd8942f1e68a57376"></span>bool <code class="descname">sequenceItemExists</code><span class="sig-paren">(</span>size_t <em>dataSetId</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag18sequenceItemExistsE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for the existance of a sequence item. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the sequence item exists, false otherwise </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">dataSetId</span></code> - <p>the ID of the sequence item to check for </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag15setSequenceItemE6size_tRK7DataSet">
<span id="imebra::Tag::setSequenceItem__s.DataSetCR"></span><span class="target" id="imebraclassimebra_1_1_tag_1a6730a09ff0bf44f398a9389530918d52"></span>void <code class="descname">setSequenceItem</code><span class="sig-paren">(</span>size_t <em>dataSetId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> &amp;<em>dataSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra3Tag15setSequenceItemE6size_tRK7DataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a sequence item into the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">dataSetId</span></code> - <p>the ID of the sequence item </p>
</li>
<li><code class="first docutils literal"><span class="pre">dataSet</span></code> - <p>the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> containing the sequence item data </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag18appendSequenceItemERK7DataSet">
<span id="imebra::Tag::appendSequenceItem__DataSetCR"></span><span class="target" id="imebraclassimebra_1_1_tag_1ad4a8f9f57e04435a7f1766c2131df5a5"></span>void <code class="descname">appendSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> &amp;<em>dataSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra3Tag18appendSequenceItemERK7DataSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a sequence item into the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">dataSet</span></code> - <p>the <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> containing the sequence item data </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra3Tag11getDataTypeEv">
<span id="imebra::Tag::getDataType"></span><span class="target" id="imebraclassimebra_1_1_tag_1a824f1b53a782f061edc9242464f0c8b2"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra3Tag11getDataTypeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the tag&#8217;s data type. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s data type </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="tagid">
<h2>TagId<a class="headerlink" href="#tagid" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N6imebra5TagIdE">
<span id="imebra::TagId"></span><span class="target" id="imebraclassimebra_1_1_tag_id"></span><em class="property">class </em><code class="descclassname">imebra::</code><code class="descname">TagId</code><a class="headerlink" href="#_CPPv2N6imebra5TagIdE" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a Dicom tag&#8217;s identification. </p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6imebra5TagId5TagIdEv">
<span id="imebra::TagId::TagId"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1a0f6f102237de0448186e304dd08901b4"></span><code class="descname">TagId</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra5TagId5TagIdEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor. </p>
<p>Initializes the group id and the tag id to 0. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE">
<span id="imebra::TagId::TagId__std::uint16_t.std::uint16_t"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1a75bd191ce3e71c55ecc90636a8ce58df"></span><code class="descname">TagId</code><span class="sig-paren">(</span>std::uint16_t <em>groupId</em>, std::uint16_t <em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">groupId</span></code> - <p>the group id </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag id </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE">
<span id="imebra::TagId::TagId__std::uint16_t.std::uint32_t.std::uint16_t"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1a0a5f5ddfa7726cf777087b17d6204e8b"></span><code class="descname">TagId</code><span class="sig-paren">(</span>std::uint16_t <em>groupId</em>, std::uint32_t <em>groupOrder</em>, std::uint16_t <em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">groupId</span></code> - <p>the group id </p>
</li>
<li><code class="first docutils literal"><span class="pre">groupOrder</span></code> - <p>old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </p>
</li>
<li><code class="first docutils literal"><span class="pre">tagId</span></code> - <p>the tag id </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra5TagId5TagIdE7tagId_t">
<span id="imebra::TagId::TagId__tagId_t"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1ad19878723a6f0c8234c56d108e891fad"></span><code class="descname">TagId</code><span class="sig-paren">(</span><a class="reference internal" href="dicom_dictionary_classes.html#_CPPv2N6imebra7tagId_tE" title="imebra::tagId_t">tagId_t</a> <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra5TagId5TagIdE7tagId_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Very large enumeration classes cause an error in Java, therefore the tagId_t enumeration is not supported in Java. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">id</span></code> - <p>an enumeration representing a tag group and id</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE">
<span id="imebra::TagId::TagId__tagId_t.std::uint32_t"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1ad2a33774c78d73e060d535d00739140e"></span><code class="descname">TagId</code><span class="sig-paren">(</span><a class="reference internal" href="dicom_dictionary_classes.html#_CPPv2N6imebra7tagId_tE" title="imebra::tagId_t">tagId_t</a> <em>id</em>, std::uint32_t <em>groupOrder</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">id</span></code> - <p>an enumeration representing a tag group and id </p>
</li>
<li><code class="first docutils literal"><span class="pre">groupOrder</span></code> - <p>old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra5TagId10getGroupIdEv">
<span id="imebra::TagId::getGroupId"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1a502f48a8db2f380029a04d4f322fc0b2"></span>std::uint16_t <code class="descname">getGroupId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra5TagId10getGroupIdEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the group id. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the group id </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra5TagId13getGroupOrderEv">
<span id="imebra::TagId::getGroupOrder"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1aec334c0eb8e38531059127c79ece7822"></span>std::uint32_t <code class="descname">getGroupOrder</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra5TagId13getGroupOrderEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the group order. Old DICOM files may have several groups with the same id. This value specifies which of the groups with the same id has been taken into consideration. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the group order </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra5TagId8getTagIdEv">
<span id="imebra::TagId::getTagId"></span><span class="target" id="imebraclassimebra_1_1_tag_id_1a89695c3768cb2db0c26be35cf6464744"></span>std::uint16_t <code class="descname">getTagId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra5TagId8getTagIdEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the tag id. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag id </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="readingdatahandler">
<h2>ReadingDataHandler<a class="headerlink" href="#readingdatahandler" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N6imebra18ReadingDataHandlerE">
<span id="imebra::ReadingDataHandler"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler"></span><em class="property">class </em><code class="descclassname">imebra::</code><code class="descname">ReadingDataHandler</code><a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandlerE" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> class allows reading the content of a Dicom <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p><a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> is able to return the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s content as a string, a number, a date/time or an age.</p>
<p>In order to obtain a <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object for a specific <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a> stored in a <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, call <a class="reference internal" href="#imebraclassimebra_1_1_data_set_1a07cb73035f85ecda6ef255408c44b876"><span class="std std-ref">DataSet::getReadingDataHandler()</span></a> or <a class="reference internal" href="#imebraclassimebra_1_1_tag_1aa41344971a5dab80f2aa7cf043ff4510"><span class="std std-ref">Tag::getReadingDataHandler()</span></a>.</p>
<p>The <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object keeps a reference to the buffer&#8217;s memory: the buffer&#8217;s memory is never modified but only replaced by a new memory area, therefore the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> client does not need to worry about other clients modifying the memory being read. </p>
<p>Subclassed by <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">imebra::ReadingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler7getSizeEv">
<span id="imebra::ReadingDataHandler::getSize"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"></span>size_t <code class="descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler7getSizeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of elements in the <a class="reference internal" href="#imebraclassimebra_1_1_tag"><span class="std std-ref">Tag</span></a>&#8216;s buffer handled by the data handler. </p>
<p>If the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object is related to a buffer that contains strings then it returns the number of strings stored in the buffer. Multiple strings are separated by a separator char.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of elements stored in the handled Dicom buffer </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler11getDataTypeEv">
<span id="imebra::ReadingDataHandler::getDataType"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1aa85cd997982b9b078878817268dea6a4"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler11getDataTypeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data type (VR) of the data handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the data type of the handled data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler13getSignedLongE6size_t">
<span id="imebra::ReadingDataHandler::getSignedLong__s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a9c3c1bbdc0b1e55ba9261de1e7967b7e"></span>std::int32_t <code class="descname">getSignedLong</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler13getSignedLongE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a buffer&#8217;s value as signed long integer (32 bit). </p>
<p>If the buffer&#8217;s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a signed 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"><span class="std std-ref">getSize()</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler15getUnsignedLongE6size_t">
<span id="imebra::ReadingDataHandler::getUnsignedLong__s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a4bdc49764fb06c86a0cfc3135eb4f1a9"></span>std::uint32_t <code class="descname">getUnsignedLong</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler15getUnsignedLongE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a buffer&#8217;s value as an unsigned long integer (32 bit). </p>
<p>If the buffer&#8217;s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as an unsigned 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"><span class="std std-ref">getSize()</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler9getDoubleE6size_t">
<span id="imebra::ReadingDataHandler::getDouble__s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a8cbe3e207cb9cb15ce84d27e3ca811d4"></span>double <code class="descname">getDouble</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler9getDoubleE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a buffer&#8217;s value as a double floating point value (64 bit). </p>
<p>If the buffer&#8217;s value cannot be converted to a double value then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a double floating point value (64 bit) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"><span class="std std-ref">getSize()</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler9getStringE6size_t">
<span id="imebra::ReadingDataHandler::getString__s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a3a5f7599a9ff841b612e14397380e5e1"></span>std::string <code class="descname">getString</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler9getStringE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a buffer&#8217;s value as an ASCII string. </p>
<p>If the buffer&#8217;s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as an ASCII string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"><span class="std std-ref">getSize()</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler16getUnicodeStringE6size_t">
<span id="imebra::ReadingDataHandler::getUnicodeString__s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a9c3c74f2a95d0fd4eaa020fd19c6dbd9"></span>std::wstring <code class="descname">getUnicodeString</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler16getUnicodeStringE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a buffer&#8217;s value as a Unicode string. </p>
<p>If the buffer&#8217;s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a Unicode string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"><span class="std std-ref">getSize()</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler7getDateE6size_t">
<span id="imebra::ReadingDataHandler::getDate__s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a2a87f877cbfc8dba15e57e7704991a16"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra4DateE" title="imebra::Date">Date</a> <code class="descname">getDate</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler7getDateE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a buffer&#8217;s value a date or time. </p>
<p>If the buffer&#8217;s value cannot be converted to a date or time then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as a date or time </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"><span class="std std-ref">getSize()</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18ReadingDataHandler6getAgeE6size_t">
<span id="imebra::ReadingDataHandler::getAge__s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_1a7992f2f6830b671b848c1ebf826ad26f"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra3AgeE" title="imebra::Age">Age</a> <code class="descname">getAge</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18ReadingDataHandler6getAgeE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a buffer&#8217;s value as an <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the buffer&#8217;s value cannot be converted to an <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag&#8217;s value as an <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_1a81a593d28e74a5b321377f1b71d607d1"><span class="std std-ref">getSize()</span></a> </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="readingdatahandlernumeric">
<h2>ReadingDataHandlerNumeric<a class="headerlink" href="#readingdatahandlernumeric" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumericE">
<span id="imebra::ReadingDataHandlerNumeric"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric"></span><em class="property">class </em><code class="descclassname">imebra::</code><code class="descname">ReadingDataHandlerNumeric</code><a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumericE" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialized <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer&#8217;s data. </p>
<p>Inherits from <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler"><span class="std std-ref">imebra::ReadingDataHandler</span></a></p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumeric9getMemoryEv">
<span id="imebra::ReadingDataHandlerNumeric::getMemory"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric_1a6964c55ac28b7d8950f8a28b7925c468"></span><a class="reference internal" href="memory_management_classes.html#_CPPv2N6imebra10ReadMemoryE" title="imebra::ReadMemory">ReadMemory</a> *<code class="descname">getMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumeric9getMemoryEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#imebraclassimebra_1_1_read_memory"><span class="std std-ref">ReadMemory</span></a> object referencing the raw buffer&#8217;s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="memory_management_classes.html#imebraclassimebra_1_1_read_memory"><span class="std std-ref">ReadMemory</span></a> object referencing the raw buffer&#8217;s data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumeric4dataEPc6size_t">
<span id="imebra::ReadingDataHandlerNumeric::data__cP.s"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric_1abbfbd886733afade7bd839cfffc6954e"></span>size_t <code class="descname">data</code><span class="sig-paren">(</span>char *<em>destination</em>, size_t <em>destinationSize</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumeric4dataEPc6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the buffer&#8217;s raw memory content into the specified buffer. </p>
<p>If the allocated buffer is not large enough then the method doesn&#8217;t copy any data and just returns the required buffer&#8217; size.</p>
<p><strong>Java</strong></p>
<p>In Java this method accepts a single parameter (a byte array). The size of the byte array must be equal or greater than the number of bytes stored by the data handler.</p>
<p><strong>Python</strong></p>
<p>In Python this method accepts a single parameter (an array). The size of the array (in bytes) must be equal or greater than the number of bytes stored by the data handler.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes to be copied into the pre-allocated buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">destination</span></code> - <p>a pointer to the allocated buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">destinationSize</span></code> - <p>the size of the allocated buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumeric4dataEP6size_t">
<span id="imebra::ReadingDataHandlerNumeric::data__sP"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric_1af355c4790ab13e02edb5b77815cf5408"></span><em class="property">const</em> char *<code class="descname">data</code><span class="sig-paren">(</span>size_t *<em>pDataSize</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumeric4dataEP6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the buffer&#8217;s raw memory content. </p>
<p>The referenced buffer is owned by the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object and must not be freed by the client.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a pointer to the buffer&#8217;s raw memory. The referenced buffer is owned by the <a class="reference internal" href="#imebraclassimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object and must not be freed by the client. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">pDataSize</span></code> - <p>a variable that will contain the raw memory&#8217;s size in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumeric11getUnitSizeEv">
<span id="imebra::ReadingDataHandlerNumeric::getUnitSize"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric_1a0f1b9a80cd368c498dab0074ece08b0e"></span>size_t <code class="descname">getUnitSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumeric11getUnitSizeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes occupied by the numbers handled by the data handler </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumeric8isSignedEv">
<span id="imebra::ReadingDataHandlerNumeric::isSigned"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric_1a453c3bb77c3ce39635f9c4fe3bb2e466"></span>bool <code class="descname">isSigned</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumeric8isSignedEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the numbers stored in the buffer are signed, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers stored in the buffer are signed, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumeric7isFloatEv">
<span id="imebra::ReadingDataHandlerNumeric::isFloat"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric_1aa068be220b75cec5e4162139b8be9d15"></span>bool <code class="descname">isFloat</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumeric7isFloatEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers stored in the buffer are floating point numbers, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric">
<span id="imebra::ReadingDataHandlerNumeric::copyTo__WritingDataHandlerNumericCR"></span><span class="target" id="imebraclassimebra_1_1_reading_data_handler_numeric_1a4d61eb868ecce30246f449ed091a7105"></span>void <code class="descname">copyTo</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> &amp;<em>destination</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the content of the data handler into another data handler, converting the data to the destination handler data type. </p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>the size of the destination data handler stays unchanged: if the destination too small to contain all the data to be copied then only a part of the data will be copied.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">destination</span></code> - <p>the destination data handler </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="writingdatahandler">
<h2>WritingDataHandler<a class="headerlink" href="#writingdatahandler" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N6imebra18WritingDataHandlerE">
<span id="imebra::WritingDataHandler"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler"></span><em class="property">class </em><code class="descclassname">imebra::</code><code class="descname">WritingDataHandler</code><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandlerE" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> class allows to write the content of a Dicom tag&#8217;s buffer. </p>
<p><a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is able to write into the buffer&#8217;s content strings, numbers, date/time or ages.</p>
<p>In order to obtain a <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object for a specific tag stored in a <a class="reference internal" href="#imebraclassimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, call <a class="reference internal" href="#imebraclassimebra_1_1_data_set_1adb58aee90c373a1703f82d56ad5b1fa7"><span class="std std-ref">DataSet::getWritingDataHandler()</span></a> or <a class="reference internal" href="#imebraclassimebra_1_1_tag_1adff439da273315a0ae9f64af917b12ce"><span class="std std-ref">Tag::getWritingDataHandler()</span></a>.</p>
<p>The <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object always works on a new and clean memory area. The buffer&#8217;s memory is replaced by the <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> memory when the data handler is destroyed. </p>
<p>Subclassed by <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">imebra::WritingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandlerD0Ev">
<span id="imebra::WritingDataHandler::~WritingDataHandler"></span>virtual <span class="target" id="imebraclassimebra_1_1_writing_data_handler_1a5ace3e9ba974b35edaae140a7f72a8dd"></span><code class="descname">~WritingDataHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandlerD0Ev" title="Permalink to this definition">¶</a></dt>
<dd><p>Destructor: replaces the tag buffer&#8217;s memory with the memory created by this <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler7setSizeE6size_t">
<span id="imebra::WritingDataHandler::setSize__s"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1a413692734d2094cbb76902e042282c4f"></span>void <code class="descname">setSize</code><span class="sig-paren">(</span>size_t <em>elementsNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler7setSizeE6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the memory to contain the specified number of elements. </p>
<p>By default, the <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> buffer allocates an empty memory block that must be resized in order to be filled with data.</p>
<p>The type of the contained elements depends on the tag&#8217;s VR. The VR can be retrieved with <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1a5df1d9a93658e0efdac8013a1813fe6a"><span class="std std-ref">getDataType()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">elementsNumber</span></code> - <p>the number of elements to store in the buffer. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler7getSizeEv">
<span id="imebra::WritingDataHandler::getSize"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"></span>size_t <code class="descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler7getSizeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the number of elements that can be stored in the buffer controlled by <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
<p>The memory size can be changed with <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1a413692734d2094cbb76902e042282c4f"><span class="std std-ref">setSize()</span></a>.</p>
<p>The type of the contained elements depends on the tag&#8217;s VR. The VR can be retrieved with <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1a5df1d9a93658e0efdac8013a1813fe6a"><span class="std std-ref">getDataType()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of elements that can be stored in the buffer </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler11getDataTypeEv">
<span id="imebra::WritingDataHandler::getDataType"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1a5df1d9a93658e0efdac8013a1813fe6a"></span><a class="reference internal" href="definition_classes.html#_CPPv2N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler11getDataTypeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data type (VR) of the data handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the data type of the handled data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE">
<span id="imebra::WritingDataHandler::setSignedLong__s.std::int32_t"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1aebbdfef8ad1edfb312c7cc5a35e18a2a"></span>void <code class="descname">setSignedLong</code><span class="sig-paren">(</span>size_t <em>index</em>, std::int32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a signed long integer (32 bit). </p>
<p>If the value cannot be converted from a signed long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"><span class="std std-ref">getSize()</span></a> </p>
</li>
<li><code class="first docutils literal"><span class="pre">value</span></code> - <p>the value to write </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE">
<span id="imebra::WritingDataHandler::setUnsignedLong__s.std::uint32_t"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1a6e33479a17119d1aa34e230fa86cd43b"></span>void <code class="descname">setUnsignedLong</code><span class="sig-paren">(</span>size_t <em>index</em>, std::uint32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an unsigned long integer (32 bit). </p>
<p>If the value cannot be converted from an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"><span class="std std-ref">getSize()</span></a> </p>
</li>
<li><code class="first docutils literal"><span class="pre">value</span></code> - <p>the value to write </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler9setDoubleE6size_td">
<span id="imebra::WritingDataHandler::setDouble__s.double"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1a9694a54a6cb41fbe599b68afad06fda9"></span>void <code class="descname">setDouble</code><span class="sig-paren">(</span>size_t <em>index</em>, double <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler9setDoubleE6size_td" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a double floating point value (64 bit). </p>
<p>If the value cannot be converted from a double floating point then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"><span class="std std-ref">getSize()</span></a> </p>
</li>
<li><code class="first docutils literal"><span class="pre">value</span></code> - <p>the value to write </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE">
<span id="imebra::WritingDataHandler::setString__s.ssCR"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1aa33cc25f450fabfccf661651b23fa9a0"></span>void <code class="descname">setString</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> std::string &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a string. </p>
<p>If the value cannot be converted from a string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"><span class="std std-ref">getSize()</span></a> </p>
</li>
<li><code class="first docutils literal"><span class="pre">value</span></code> - <p>the value to write </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE">
<span id="imebra::WritingDataHandler::setUnicodeString__s.std::wstringCR"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1af31ab17196c1cd5aadfb0ef04dc155ac"></span>void <code class="descname">setUnicodeString</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> std::wstring &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an Unicode string. </p>
<p>If the value cannot be converted from a Unicode string then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"><span class="std std-ref">getSize()</span></a> </p>
</li>
<li><code class="first docutils literal"><span class="pre">value</span></code> - <p>the value to write </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler7setDateE6size_tRK4Date">
<span id="imebra::WritingDataHandler::setDate__s.DateCR"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1abb744a7256dbbb8e4468c561f20dc579"></span>void <code class="descname">setDate</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler7setDateE6size_tRK4Date" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a date and/or a time. </p>
<p>If the value cannot be converted from a <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_date"><span class="std std-ref">Date</span></a> then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"><span class="std std-ref">getSize()</span></a> </p>
</li>
<li><code class="first docutils literal"><span class="pre">date</span></code> - <p>the value to write </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra18WritingDataHandler6setAgeE6size_tRK3Age">
<span id="imebra::WritingDataHandler::setAge__s.AgeCR"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_1aa0c1f4ff7ff62f052f1c6f1537abcbc1"></span>void <code class="descname">setAge</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv2N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>age</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra18WritingDataHandler6setAgeE6size_tRK3Age" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> value. </p>
<p>If the value cannot be converted from an <a class="reference internal" href="definition_classes.html#imebrastructimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#imebraclassimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">index</span></code> - <p>the element number within the buffer. Must be smaller than <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_1afed420eb6ac2b960546f6780da01759e"><span class="std std-ref">getSize()</span></a> </p>
</li>
<li><code class="first docutils literal"><span class="pre">age</span></code> - <p>the value to write </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="writingdatahandlernumeric">
<h2>WritingDataHandlerNumeric<a class="headerlink" href="#writingdatahandlernumeric" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumericE">
<span id="imebra::WritingDataHandlerNumeric"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric"></span><em class="property">class </em><code class="descclassname">imebra::</code><code class="descname">WritingDataHandlerNumeric</code><a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumericE" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialized <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer&#8217;s data. </p>
<p>Inherits from <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler"><span class="std std-ref">imebra::WritingDataHandler</span></a></p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric9getMemoryEv">
<span id="imebra::WritingDataHandlerNumeric::getMemory"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1a76a27673e77065869ddfe7cd7bfeecfb"></span><a class="reference internal" href="memory_management_classes.html#_CPPv2N6imebra15ReadWriteMemoryE" title="imebra::ReadWriteMemory">ReadWriteMemory</a> *<code class="descname">getMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric9getMemoryEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#imebraclassimebra_1_1_read_write_memory"><span class="std std-ref">ReadWriteMemory</span></a> object referencing the raw buffer&#8217;s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="memory_management_classes.html#imebraclassimebra_1_1_read_write_memory"><span class="std std-ref">ReadWriteMemory</span></a> object referencing the raw buffer&#8217;s data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t">
<span id="imebra::WritingDataHandlerNumeric::assign__cCP.s"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1a41a31fa7c7f9103c32e70129dc48c7fb"></span>void <code class="descname">assign</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>source</em>, size_t <em>sourceSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the content of the specified buffer into the content managed by data handler. </p>
<p><strong>Java</strong></p>
<p>In Java this method accepts a single parameter (a byte array).</p>
<p><strong>Python</strong></p>
<p>In Python this method accepts a single parameter (an array).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">source</span></code> - <p>a pointer to the source memory buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">sourceSize</span></code> - <p>the number of bytes to copy and the new memory size </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric4dataEP6size_t">
<span id="imebra::WritingDataHandlerNumeric::data__sP"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1a657955fda6d3cb73c27745f30e0abe39"></span>char *<code class="descname">data</code><span class="sig-paren">(</span>size_t *<em>pDataSize</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric4dataEP6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the buffer&#8217;s raw memory content. </p>
<p>The referenced buffer is owned by the <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object and must not be freed by the client.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a pointer to the buffer&#8217;s raw memory. The referenced buffer is owned by the <a class="reference internal" href="#imebraclassimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object and must not be freed by the client </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">pDataSize</span></code> - <p>a variable that will contain the raw memory&#8217;s size in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric4dataEPc6size_t">
<span id="imebra::WritingDataHandlerNumeric::data__cP.s"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1a8836cdfe2c6beaef4270a4f622f1e6e1"></span>size_t <code class="descname">data</code><span class="sig-paren">(</span>char *<em>destination</em>, size_t <em>destinationSize</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric4dataEPc6size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the raw memory content into the specified buffer. </p>
<p>If the allocated buffer is not large enough then the method doesn&#8217;t copy any data and just returns the required buffer&#8217; size.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes to be copied into the pre-allocated buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">destination</span></code> - <p>a pointer to the allocated buffer </p>
</li>
<li><code class="first docutils literal"><span class="pre">destinationSize</span></code> - <p>the size of the allocated buffer, in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric11getUnitSizeEv">
<span id="imebra::WritingDataHandlerNumeric::getUnitSize"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1af77e1a8cbe79d1447d8ddfdcbdc9b6c0"></span>size_t <code class="descname">getUnitSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric11getUnitSizeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes occupied by the numbers handled by the data handler </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric8isSignedEv">
<span id="imebra::WritingDataHandlerNumeric::isSigned"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1ad60478cc0b079c449d6e83f8ad493eb7"></span>bool <code class="descname">isSigned</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric8isSignedEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the numbers handled by the data handler are signed, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers handled by the data handler are signed, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric7isFloatEv">
<span id="imebra::WritingDataHandlerNumeric::isFloat"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1aa562ef009eef81c107a7509e0b3b610e"></span>bool <code class="descname">isFloat</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric7isFloatEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers stored in the buffer are floating point numbers, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric">
<span id="imebra::WritingDataHandlerNumeric::copyFrom__ReadingDataHandlerNumericCR"></span><span class="target" id="imebraclassimebra_1_1_writing_data_handler_numeric_1a05b81477969c5da01eb8dfaac52bc894"></span>void <code class="descname">copyFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies data from another data handler, converting the data type if necessary. </p>
<p>The data handler is resized to the same size of the source data handler.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">source</span></code> - <p>the data handler from which the data must be copied </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="imaging_classes.html" class="btn btn-neutral float-right" title="Imaging classes" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="loading_saving_classes.html" class="btn btn-neutral" title="Loading &amp; saving classes" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="copyright.html">Copyright</a> 2016, Paolo Brandoli.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'4.0.8.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>